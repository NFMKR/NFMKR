---
title: 微信小程序登录
date: 2024-12-04 15:42:30
tags:
---
## 登录步骤

开发微信小程序的登录功能，主要包括手机号短信登录和微信一键登录，后端需要做以下几项工作：

### 1. **手机号短信登录**
   - **发送验证码短信：**
     - 使用第三方短信服务（如阿里云、腾讯云等）来发送验证码。
     - 用户提交手机号后，后台生成验证码并发送给用户。为了避免频繁发送验证码，可以使用 **Redis** 或其他缓存机制记录发送的验证码，设置过期时间和防止重复发送。
     - 后端需提供一个接口来接收验证码请求，验证用户输入的验证码是否正确，并设置有效期。

   - **校验手机号和验证码：**
     - 在用户提交验证码时，后端接收到手机号和验证码，进行验证。
     - 比对后台存储的验证码是否与用户提交的匹配。
     - 短信验证码成功后，返回登录成功的响应，生成并返回 **JWT token** 或其他认证凭证。

   - **验证码限制：**
     - 限制用户在短时间内请求验证码的次数（通常为每分钟或每小时限制一次请求）。
     - 防止恶意刷验证码攻击。

### 2. **微信一键登录**
   - **获取微信用户信息：**
     - 微信小程序提供了 `wx.login()` 接口，前端获取到 **code**。
     - 后端通过微信的 `code` 调用微信的登录接口，获取到 **openid** 和 **session_key**。
     - 后端使用 `appid` 和 `secret`，向微信的接口请求换取 **session_key** 和 **openid**。

   - **处理微信登录信息：**
     - **用户唯一标识**：通过微信的 `openid` 获取用户的唯一身份信息，如果是第一次登录，后端可以将用户信息存储到数据库。
     - **Session管理**：为了保持用户的会话状态，可以生成 **JWT token**，并将其返回给客户端，客户端存储 token 后，之后每次请求都会带上该 token 进行身份验证。

   - **处理微信用户的绑定：**
     - 在第一次微信登录时，可以要求用户填写手机号或其他信息完成账户绑定。
     - 如果手机号已经绑定过微信账号，可以跳过手机号验证。

### 3. **后端要做的工作：**
   - **创建用户模型**：包括手机号、微信openid、session_key、用户信息等字段。
   - **实现验证码功能**：包括发送验证码、校验验证码、生成验证码的逻辑。
   - **JWT认证**：用户登录成功后生成并返回一个 JWT token，后续请求需要携带这个 token 进行身份验证。
   - **微信接口调用**：根据前端传来的 `code`，通过微信API获取用户信息，并确保每次登录都能获取到有效的 **openid**。
   - **用户数据存储**：如果是新用户，保存用户的基本信息到数据库；如果是老用户，则更新用户信息。

### 4. **前端工作：**
   - **手机号登录：**
     - 使用微信小程序提供的短信验证 API 调用后端接口，发送验证码并校验用户输入的验证码。
     - 登录成功后，存储返回的 JWT token，用于后续的请求认证。

   - **微信一键登录：**
     - 使用 `wx.login()` 获取微信返回的 `code`，并传递给后端进行进一步处理。
     - 后端返回的 token 存储在前端，用于后续的请求认证。

### 5. **安全性考虑：**
   - **加密**：确保密码、验证码等敏感信息在传输过程中进行加密（HTTPS）。
   - **验证码防刷**：设置发送验证码的频率限制，防止刷验证码。
   - **JWT过期机制**：设置 token 的过期时间，并实现刷新 token 机制。
   - **用户数据保护**：避免泄露用户的 `session_key`、`openid` 等敏感信息。

### 6. **流程图：**
   - **手机号登录流程：**
     1. 用户提交手机号请求验证码
     2. 后端生成验证码并通过短信服务发送
     3. 用户输入验证码
     4. 后端校验验证码
     5. 登录成功，生成 JWT token 返回前端

   - **微信一键登录流程：**
     1. 前端调用 `wx.login()` 获取 `code`
     2. 将 `code` 传给后端
     3. 后端用 `code` 调用微信 API 获取 `openid` 和 `session_key`
     4. 根据 `openid` 查找或创建用户，并生成 JWT token 返回前端

通过这些步骤，你的微信小程序登录功能就能实现手机号短信登录和微信一键登录的功能，并确保安全性和用户体验。如果以后要扩展登录方式（如通过第三方平台登录），可以借鉴这个架构。

## 登录开发中用到的中间件、功能函数

在实现微信小程序的登录功能时，后端需要编写一些功能函数和中间件，以支持用户的注册、登录、会话管理和安全性验证。下面是一些可能需要的功能函数和中间件，以及它们的作用：

### 1. **功能函数**

#### 1.1 发送验证码
用于生成并发送短信验证码。

```javascript
const { sendSms } = require("@/utils/sms"); // 这里假设你有一个 `sendSms` 工具来发送验证码短信

function sendVerificationCode(phone, verificationCode) {
  try {
    sendSms(phone, verificationCode); // 调用外部短信服务
  } catch (error) {
    throw new Error("发送验证码失败");
  }
}
```

#### 1.2 验证验证码
用于验证用户提交的验证码是否正确。

```javascript
const redisClient = require("@/config/redis");

async function validateVerificationCode(phone, verificationCode) {
  const storedCode = await redisClient.get(`${phone}:verificationCode`);
  if (!storedCode) {
    throw new Error("验证码不存在或已过期");
  }

  const storedCodeList = storedCode.split(":");
  if (storedCodeList[1] !== verificationCode) {
    throw new Error("验证码不正确");
  }
  
  // 验证通过后，删除验证码，防止重复使用
  await redisClient.del(`${phone}:verificationCode`);
}
```

#### 1.3 微信登录
通过微信 `code` 获取用户的 `openid` 和 `session_key`。

```javascript
const axios = require("axios");

async function wechatLogin(code) {
  const appid = process.env.WECHAT_APPID;
  const secret = process.env.WECHAT_SECRET;
  const url = `https://api.weixin.qq.com/sns/jscode2session?appid=${appid}&secret=${secret}&js_code=${code}&grant_type=authorization_code`;

  try {
    const response = await axios.get(url);
    const { openid, session_key, errcode, errmsg } = response.data;
    if (errcode) {
      throw new Error(`微信登录失败: ${errmsg}`);
    }
    return { openid, session_key };
  } catch (error) {
    throw new Error("微信登录失败: " + error.message);
  }
}
```

#### 1.4 生成JWT Token
用于生成登录时使用的 JWT token。

```javascript
const jwt = require("jsonwebtoken");

function generateToken(userInfo, clientType) {
  const payload = {
    _id: userInfo._id,
    phone: userInfo.phone,
    clientType: clientType, // 区分是来自小程序还是App
  };

  const secret = process.env.JWT_SECRET_KEY;
  const options = { expiresIn: '1h' }; // 1小时过期
  return jwt.sign(payload, secret, options);
}
```

#### 1.5 用户信息存储
根据微信登录后的 `openid`，检查用户是否已存在，如果不存在则创建一个新的用户。

```javascript
const User = require("@/models/user/User");

async function getOrCreateUserByPhoneOrOpenid(phone, openid) {
  let user = await User.findOne({ phone }); // 查找手机号对应的用户
  if (!user) {
    // 如果没有手机号，尝试通过openid查找
    user = await User.findOne({ openid });
    if (!user) {
      // 如果找不到该用户，创建一个新用户
      user = new User({ phone, openid });
      await user.save();
    }
  }
  return user;
}
```

### 2. **中间件**

#### 2.1 验证请求数据
用于验证请求体中的数据是否符合要求，通常是用于手机号码和验证码的验证。

```javascript
const { body, validationResult } = require("express-validator");

function validateLoginData(req, res, next) {
  body("phone")
    .isLength({ min: 11, max: 11 })
    .withMessage("手机号必须是11位")
    .isString()
    .withMessage("请输入有效的手机号")
    .matches(/^[1-9]\d{10}$/)
    .withMessage("请输入有效的手机号")(req, res, () => {});

  body("verificationCode")
    .isLength({ min: 6, max: 6 })
    .withMessage("验证码必须是6位数字")
    .matches(/^\d{6}$/)
    .withMessage("验证码必须是6位数字")(req, res, () => {});

  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      code: 400,
      errors: errors.array(),
    });
  }
  next();
}
```

#### 2.2 验证登录状态（JWT Token 验证）
用于在每个需要用户登录的请求中，验证 JWT token 是否有效。

```javascript
const jwt = require("jsonwebtoken");

function authMiddleware(req, res, next) {
  const token = req.headers["authorization"];
  if (!token) {
    return res.status(401).json({
      code: 401,
      error: "没有提供 token",
    });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET_KEY);
    req.user = decoded;
    next(); // 验证通过，继续执行
  } catch (error) {
    return res.status(401).json({
      code: 401,
      error: "无效的 token",
    });
  }
}
```

#### 2.3 校验是否重复请求验证码
为了防止同一手机号频繁请求验证码，可以使用 Redis 存储验证码请求状态，判断是否存在未过期的验证码请求。

```javascript
const redisClient = require("@/config/redis");

async function checkCaptchaRequestLimit(phone) {
  const exists = await redisClient.get(phone);
  if (exists) {
    const ttl = await redisClient.ttl(phone); // 获取剩余过期时间
    return {
      allowed: false,
      ttl, // 返回等待时间
    };
  }
  return { allowed: true };
}
```

### 3. **总结**
这些功能函数和中间件可以帮助你完成微信小程序登录功能的后端部分：

- **`sendVerificationCode`**：发送短信验证码。
- **`validateVerificationCode`**：验证用户输入的验证码是否正确。
- **`wechatLogin`**：根据前端传递的 `code` 获取微信 `openid` 和 `session_key`。
- **`generateToken`**：生成 JWT token，用于登录会话管理。
- **`getOrCreateUserByPhoneOrOpenid`**：根据手机号或微信 `openid` 获取或创建用户。
- **`validateLoginData`**：验证手机号和验证码是否符合规则。
- **`authMiddleware`**：验证请求中携带的 JWT token 是否有效。
- **`checkCaptchaRequestLimit`**：防止用户在短时间内频繁请求验证码。

通过这些函数和中间件，你可以在后端实现用户登录、验证码校验、会话管理等功能，保证微信小程序登录功能的安全性和用户体验。

## 登录模型和路由

在开发微信小程序的登录功能时，后端的 **模型** 和 **路由** 是核心部分。下面我们将通过示例代码来详细说明如何设计这两部分内容。

### 1. **模型（Model）设计**

模型用于定义与数据库交互的数据结构。在你的场景中，我们需要设计两个模型：
- **用户模型（User Model）**：保存用户的基本信息，如手机号、微信 `openid`、验证码等。
- **验证码模型（VerificationCode Model）**：用于存储验证码，或者我们也可以直接使用 Redis 来存储验证码（如上文所述）。

#### 1.1 用户模型（User Model）
我们将使用 `mongoose` 来定义用户模型，它会存储用户的基本信息，并且支持通过 `phone` 和 `openid` 查找用户。

```javascript
const mongoose = require("mongoose");

// 定义用户的 Schema
const userSchema = new mongoose.Schema({
  phone: { type: String, required: true, unique: true }, // 手机号
  openid: { type: String, unique: true }, // 微信 openid
  nickname: { type: String }, // 昵称
  avatar: { type: String }, // 头像
  birthday: { type: Date }, // 生日
  verificationCode: { // 存储验证码
    miniprogram: { type: String }, // 小程序验证码
    app: { type: String }, // App验证码
  },
  createdAt: { type: Date, default: Date.now }, // 创建时间
  updatedAt: { type: Date, default: Date.now }, // 更新时间
});

// 用户模型
const User = mongoose.model("User", userSchema);

module.exports = User;
```

#### 1.2 验证码模型（VerificationCode Model）（可选）
如果你需要将验证码存储到数据库而非 Redis，可以使用类似下面的模型。

```javascript
const mongoose = require("mongoose");

// 验证码 Schema
const verificationCodeSchema = new mongoose.Schema({
  phone: { type: String, required: true, unique: true }, // 手机号
  code: { type: String, required: true }, // 验证码
  createdAt: { type: Date, default: Date.now }, // 创建时间
  expiresAt: { type: Date, required: true }, // 过期时间
});

// 验证码模型
const VerificationCode = mongoose.model("VerificationCode", verificationCodeSchema);

module.exports = VerificationCode;
```

### 2. **路由（Router）设计**

在路由中，我们会根据不同的请求实现用户的登录、验证码发送等功能。通常情况下，我们会使用 Express.js 来创建这些路由。

#### 2.1 安装依赖

首先，我们需要安装一些依赖，如 `express`、`mongoose`、`ioredis`（如果使用 Redis 存储验证码）等。

```bash
npm install express mongoose ioredis express-validator
```

#### 2.2 路由设计

我们将设计几个主要的路由来处理登录、获取用户信息、发送验证码等操作。

##### 2.2.1 发送验证码的路由

```javascript
const express = require("express");
const { body, validationResult } = require("express-validator");
const redisClient = require("@/config/redis");
const generateVerificationCode = require("@/utils/generateCode");
const { sendSms } = require("@/utils/sms");

const router = express.Router();

// 验证手机号格式
const validateUserPhone = [
  body("phone")
    .isLength({ min: 11, max: 11 })
    .withMessage("手机号必须是11位")
    .matches(/^[1-9]\d{10}$/)
    .withMessage("请输入有效的手机号"),
];

router.post("/sendsms", validateUserPhone, async (req, res) => {
  const phone = req.body.phone;

  // 校验数据
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    // 校验是否有未过期的验证码请求
    const exists = await redisClient.get(phone);
    if (exists) {
      const ttl = await redisClient.ttl(phone);
      return res.status(429).json({
        code: 429,
        error: `请在${ttl}秒后再试`,
      });
    }

    // 生成验证码
    const verificationCode = generateVerificationCode();

    // 发送验证码
    sendSms(phone, verificationCode);

    // 存储验证码，设置10分钟过期
    await redisClient.set(`${phone}:verificationCode`, verificationCode, "EX", 600);
    await redisClient.set(phone, "requested", "EX", 60); // 设置验证码请求限制过期时间60秒

    return res.status(200).json({
      code: 200,
      message: "验证码已发送",
    });
  } catch (err) {
    console.error("请求验证码错误:", err);
    return res.status(500).json({ code: 500, error: "服务器内部错误" });
  }
});
```

##### 2.2.2 手机号验证码登录的路由

```javascript
const jwt = require("jsonwebtoken");
const User = require("@/models/user/User");

router.post("/login", async (req, res) => {
  const { phone, verificationCode } = req.body;

  try {
    // 验证码校验
    const storedCode = await redisClient.get(`${phone}:verificationCode`);
    if (!storedCode) {
      return res.status(400).json({ code: 400, error: "验证码不存在或已过期" });
    }

    if (storedCode !== verificationCode) {
      return res.status(400).json({ code: 400, error: "验证码不正确" });
    }

    // 删除验证码，防止重复使用
    await redisClient.del(`${phone}:verificationCode`);

    // 查找用户
    let user = await User.findOne({ phone });
    if (!user) {
      user = new User({ phone });
      await user.save();
    }

    // 生成 JWT Token
    const token = jwt.sign({ _id: user._id, phone: user.phone }, process.env.JWT_SECRET_KEY, {
      expiresIn: "1h",
    });

    return res.status(200).json({
      code: 200,
      message: "登录成功",
      data: { token },
    });
  } catch (err) {
    console.error("登录失败:", err);
    return res.status(500).json({ code: 500, error: "服务器内部错误" });
  }
});
```

##### 2.2.3 微信一键登录的路由

```javascript
const axios = require("axios");

router.post("/wechatlogin", async (req, res) => {
  const { code } = req.body;

  try {
    const appid = process.env.WECHAT_APPID;
    const secret = process.env.WECHAT_SECRET;
    const url = `https://api.weixin.qq.com/sns/jscode2session?appid=${appid}&secret=${secret}&js_code=${code}&grant_type=authorization_code`;

    const response = await axios.get(url);
    const { openid, session_key, errcode, errmsg } = response.data;
    if (errcode) {
      return res.status(400).json({ code: 400, error: errmsg });
    }

    // 查找或创建用户
    let user = await User.findOne({ openid });
    if (!user) {
      user = new User({ openid });
      await user.save();
    }

    // 生成 JWT Token
    const token = jwt.sign({ _id: user._id, openid: user.openid }, process.env.JWT_SECRET_KEY, {
      expiresIn: "1h",
    });

    return res.status(200).json({
      code: 200,
      message: "微信登录成功",
      data: { token },
    });
  } catch (error) {
    console.error("微信登录失败:", error);
    return res.status(500).json({ code: 500, error: "服务器内部错误" });
  }
});
```

### 3. **总结**

1. **模型（Model）**
   - **用户模型（User）**：存储用户基本信息、手机号、微信 `openid`、验证码等。
   - **验证码模型（VerificationCode）**（可选）：用于存储验证码信息。

2. **路由（Router）**
   - **发送验证码的路由**：验证手机号的格式，生成验证码，发送短信并存储验证码。
   - **手机号验证码登录路由**：验证验证码、生成 JWT Token 并返回。
   - **微信一键登录路由**：通过微信的 `code` 获取 `openid`，生成 JWT Token 并返回。

通过这些模型和路由，你可以实现微信小程序的用户登录功能，包括验证码登录和微信一键登录。